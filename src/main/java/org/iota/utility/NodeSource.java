package org.iota.utility;

import java.net.URL;
import java.util.Queue;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.atomic.AtomicInteger;

import org.iota.jota.IotaAPI;
import org.iota.jota.dto.response.GetTrytesResponse;
import org.iota.jota.utils.Parallel;

public class NodeSource {

    public static final String EMPTY_TX = "999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999";

    private IotaAPI toUpdate;
    private Queue<IotaAPI> apis;

    public NodeSource(URL target, URL[] sources) {
        toUpdate = makeApi(target);

        apis = new ConcurrentLinkedQueue<IotaAPI>();
        for (URL url : sources) {
            getApis().add(makeApi(url));
        }

        try {
            toUpdate.getNodeInfo();
        } catch (Exception e) {
            System.out.println("Failed to connect to target node");
            throw e;
        }

        // Then test all targets for at least 1 working
        if (testNodesOnline()) {
            System.out.println("Source and target nodes available..");
        } else {
            System.out.println("No source node online.. Shutting down.");
            System.exit(0);
        }
    }

    private boolean testNodesOnline() {
        AtomicInteger numSuccess = new AtomicInteger(0);
        try {
            Parallel.of(getApis(), new Parallel.Operation<IotaAPI>() {
                public void perform(IotaAPI api) {
                    try {
                        api.getNodeInfo();
                        numSuccess.incrementAndGet();
                    } catch (Exception e) {
                        System.out.println("Failed to connect API to " + api.getHost());
                        getApis().remove(api);
                    }
                }
            });
        } catch (InterruptedException e) {
            return false;
        }

        return numSuccess.get() > 0;
    }

    private static IotaAPI makeApi(URL target) {

        return new IotaAPI.Builder().port(target.getPort()).host(target.getHost()).protocol(target.getProtocol())
                .timeout(5).build();
    }

    public boolean checkTargetForTransaction(String tx) {
        GetTrytesResponse trytes = toUpdate.getTrytes(tx);
        if (trytes.getTrytes().length == 0) {
            return false;
        }

        return !trytes.getTrytes()[0].equals(EMPTY_TX);
    }

    public Queue<IotaAPI> getApis() {
        return apis;
    }

    public IotaAPI getTarget() {
        return toUpdate;
    }

    public String getTransactionTrytes(String tx) {
        String trytes = null;
        for (IotaAPI api : getApis()) {
            GetTrytesResponse trytesRes = api.getTrytes(tx);
            if (trytesRes.getTrytes().length != 0 && !trytesRes.getTrytes()[0].equals(NodeSource.EMPTY_TX)) {
                trytes = trytesRes.getTrytes()[0];
            }
        }

        return trytes;
    }
}
